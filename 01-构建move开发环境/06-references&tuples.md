# move references & tuples

> 本教程是基于aptos搭建的move智能合约开发

## 1.references(引用)
> Move有两种类型的引用：不可变的 ```&``` 和可变的```&mut```。不可变引用是只读的，不能修改基础值（或其任何字段）。可变引用允许通过写入该引用进行修改。 Move的类型系统强制执行防止引用错误的所有权规则。

+ ```&e```	创建一个不可变的引用e
+ ```&mut e```创建一个可变引用e
+ ```&e.f```创建对结构e的字段f的不可变引用
+ ```&mute.f```创建对结构e的字段f的可变引用
+ ```freeze(e)```将可变引用e转换为不可变引用
+ ```*e``` 解引用，即获取e的值
+ ```*e1 = e2``` 解引用，e2重新赋值给e1

> 如果你已经将上一讲vector中的排序算法弄懂，引用这一部分也基本明了。这里再看一个交换数值的例子

[example](https://github.com/wpf008/hello_move/blob/master/03-base-type/tests/test_references_tuples.move)
```move
public fun swap(a: &mut u8, b: &mut u8) {
    let c = *a;
    *a = *b;
    *b = c;
}
```

>为了读取引用，基础类型必须具有````copy````(复制)能力，因为读取引用会创建值的新副本。 此规则防止复制资源值;
>
>为了写入引用，基础类型必须具有````drop````删除能力，因为写入引用将丢弃（或“删除”）旧值。 此规则可防止破坏资源值。
> 
> move语言特别的特性:**类型的能力**，将在接下来的篇章中详细介绍。

## 2.tuples(元组)
>实际上````move````语言不完全支持元组,为了支持函数有多个返回值，Move具有类似元组的表达式。这些表达式在运行时不会产生具体的值(字节码中没有元组)，
> 
> 因此它们非常有限：它们只能出现在表达式中（通常在函数的返回位置）；它们不能绑定到局部变量；它们不能存储在结构中；元组类型不能用于实例化泛型。
> 
> 类似地，````unit()````是 ````Move````语言创建的一种以便基于表达式的类型。````unit()````不会产生任何运行时的值。
> 
> 我们可以认为````unit()````是一个空元组，适用于元组的任何限制也适用于 ````unit()````。

```move
//有多个返回值的函数
fun hello_tuple(): (u64, bool, address) {
    let a = 10u64;
    let b = false;
    (a, b, @sender)
}
```
>由于元组值在运行时并不真正存在，目前它们不能存储到局部变量中（但这个功能很可能很快就会出现）。因此，元组目前只能移动，因为复制它们需要先将它们放入局部变量中。

---

> 至此我们已经学会了move中的引用和元组。。
