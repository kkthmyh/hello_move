# ```move中类型的能力和所有权```

> 本教程是基于aptos搭建的move智能合约开发
----

## 1.```Abilities```
> Move语言可以给与类型一些列的能力，用于控制对给定类型的值允许哪些操作。总共有四种能力

+ ```copy```:允许复制具有此能力的类型的值
+ ```drop```:允许弹出/删除具有此能力的类型的值
+ ```store```:允许具有此功能的类型的值存在于全局存储的结构中
+ ```key```:允许类型用作全局存储操作的键值

### 1.1 ```copy```
> 复制能力允许复制具有该能力的类型的值。 它控制了使用复制运算符从局部变量中复制值以及通过解引用``` *e ``` 的引用复制值的能力。
> 如果一个值有副本，则该值内包含的所有值都有副本。

### 1.2 ```drop```

> 丢弃能力允许丢弃具有该能力的类型的值。被丢弃的意思是价值没有被转移而是在```Move```程序执行时被有效地销毁。
> 因此，此能力限制了在多个位置忽略值的能力，包括：
> + 不使用局部变量或参数中的值;
> + 不使用序列中的值；
> + 覆盖赋值变量中的值;
> + 写入 ````*e1 = e2```` 时通过引用覆盖值;
> 

### 1.3 ```store```
> 存储能力允许具有这种能力的类型的值存在于全局存储中的结构（资源）内部，但不一定作为全局存储中的顶级资源。 
> 这是唯一不直接控制操作的能力。 相反，当与 key 一起使用时，它会限制全局存储中的存在。
> 如果一个值具有存储，则该值内包含的所有值都具有存储。


### 1.4 ```key```
> ```key```能力允许该类型作为全局存储操作的键值。它对所有全局存储操作进行控制，
> 因此要使类型与```move_to```、```borrow_global```、```move_from```等一起使用。

### 1.5 ```move```语言中内置的基本类型

> 大多数```move```中原始的内置类型都有复制、删除和存储，但```signer```者除外，它只有删除。
> + ```bool```, ```u8```, ```u64```, ```u128```,  ``address``  有 ```copy```, ```drop```和 ```store的能力```
> + ```signer``` 有 ```drop```的能力
> + vector<T>是否具有```copy```,```drop```和```store```取决于泛型T具有哪些能力
> + 不可变引用```&```和可变引用```&mut```都具有有```copy```和```drop```的能力
>   + 引用里的复制和删除功能是复制和删除引用本身，而不是引用所指的内容
>   + 引用不能出现在全局存储中，因此它们没有```store```的能力
> + 基本类型都key没有，这意味着它们都不能直接用于全局存储操作
> + ```struct```具有哪些能力可以通过```has```关键字去指定,下一讲将详细介绍

----

## 2.所有权

> ```move```的所有权的设计主要有以下点:
> + 1.每个变量都具有所有权;
> + 2.每个变量的所有权的**属主**是变量所处的**作用域**里;
> + 3.可以通过 ```move``` 关键字进行变量所有权的**属主**进行转移;
> + 4.默认的传值是值拷贝，不改变变量所有权

[example]()
```move
#[test_only]
module sender::test_ownership {
    use aptos_std::debug::print;
    fun add(a: u64, b: u64):u64 {
        a+b
    }
    #[test]
    fun test_ownership() {
        let a = 20;
        let b = 10;
        let c = add(move a, b);
        //print(&a); //error Invalid usage of previously moved variable 'a'.
        print(&b);
        print(&c);
    }
}

```
>```test_ownership()``` 函数在调用```add()```函数的时候，a的所有权已经不在```test_ownership()```这个函数的作用域里了，已经转移到```add()```函数的作用域里。
> 
> 当```test_ownership()```函数之后再使用变量```a```，将会报错。

---

> 至此我们已经学习了move语言中的类型的能力和所有权。接下来我们学习```struct```，利用```struct```构建复杂的结构体并在全局存储中存储资源```resources```。
